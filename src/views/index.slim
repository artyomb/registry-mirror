doctype html
html lang="en"
  head
    meta charset="utf-8"
    meta name="viewport" content="width=device-width, initial-scale=1"
    title Docker Registry Mirror - Dashboard
    style
      |
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
          --bg: #f5f7fb;
          --panel: #ffffff;
          --border: #e5e7eb;
          --text: #1f2937;
          --muted: #6b7280;
          --blue: #1a73e8;
          --blue-weak: #e8f0fe;
          --green: #137333;
          --green-weak: #e6f4ea;
          --amber: #b45309;
          --amber-weak: #fff7ed;
          --red: #b91c1c;
          --red-weak: #fef2f2;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
          font-family: 'IBM Plex Sans', system-ui, -apple-system, sans-serif;
          background: var(--bg);
          color: var(--text);
          min-height: 100vh;
          padding: 20px;
        }
        .container { max-width: none; margin: 0 auto; }
        .header {
          background: var(--panel);
          border-radius: 0;
          padding: 24px 28px;
          margin-bottom: 22px;
          border: 1px solid var(--border);
          box-shadow: 0 1px 2px rgba(16, 24, 40, 0.06);
          text-align: left;
        }
        .header h1 {
          font-size: 1.8em;
          letter-spacing: -0.02em;
          margin-bottom: 6px;
        }
        .header p { font-size: 1em; color: var(--muted); }

        .dashboard {
          display: grid;
          grid-template-columns: repeat(12, 1fr);
          gap: 18px;
          margin-bottom: 20px;
        }
        .card {
          background: var(--panel);
          border-radius: 0;
          padding: 20px;
          border: 1px solid var(--border);
          box-shadow: 0 1px 2px rgba(16, 24, 40, 0.04);
          grid-column: span 6;
        }
        .card h2 {
          color: var(--text);
          margin-bottom: 14px;
          font-size: 1.2em;
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .metric {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 10px 0;
          border-bottom: 1px solid var(--border);
        }
        .metric:last-child { border-bottom: none; }
        .metric-label { color: var(--muted); font-weight: 500; }
        .metric-value {
          font-weight: 600;
          font-size: 0.98em;
          padding: 4px 10px;
          border-radius: 999px;
        }

        .status-healthy { background: var(--green-weak); color: var(--green); }
        .status-warning { background: var(--amber-weak); color: var(--amber); }
        .status-error { background: var(--red-weak); color: var(--red); }
        .status-info { background: var(--blue-weak); color: var(--blue); }

        .progress-bar {
          width: 100%;
          height: 6px;
          background: #eef2f7;
          border-radius: 0;
          overflow: hidden;
          margin-top: 8px;
        }
        .progress-fill { height: 100%; transition: width 0.4s ease; }
        .progress-healthy { background: #34a853; }
        .progress-warning { background: #f9ab00; }
        .progress-error { background: #ea4335; }

        .actions {
          display: flex;
          gap: 10px;
          margin-top: 12px;
          flex-wrap: wrap;
        }
        .btn {
          padding: 8px 14px;
          border: 1px solid var(--border);
          border-radius: 0;
          font-weight: 600;
          cursor: pointer;
          transition: background 0.2s ease, border-color 0.2s ease;
          text-decoration: none;
          display: inline-flex;
          align-items: center;
          gap: 8px;
          background: #fff;
          color: var(--text);
        }
        .btn-primary {
          background: var(--blue);
          color: #fff;
          border-color: var(--blue);
        }
        .btn-secondary {
          background: #f9fafb;
          color: var(--text);
        }
        .btn:hover { border-color: #cbd5e1; }

        .logs {
          background: #0f172a;
          color: #e5e7eb;
          border-radius: 0;
          padding: 20px;
          margin-top: 18px;
          font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, monospace;
          font-size: 13px;
          max-height: 360px;
          overflow-y: auto;
        }
        .logs h3 { color: #93c5fd; margin-bottom: 12px; }
        .log-entry { margin-bottom: 6px; opacity: 0.9; }
        .log-timestamp { color: #9ca3af; }
        .log-level-error { color: #fca5a5; }
        .log-level-warn { color: #fcd34d; }
        .log-level-info { color: #93c5fd; }
        .log-level-debug { color: #c4b5fd; }

        .refresh-info {
          text-align: center;
          color: var(--muted);
          margin-top: 16px;
          font-size: 0.9em;
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
        .loading { animation: pulse 1.5s infinite; }

        .emoji { font-size: 1.1em; }

        .cache-table-container { margin-top: 12px; }
        .cache-table {
          width: 100%;
          table-layout: fixed;
          border-collapse: collapse;
          font-size: 0.88em;
        }
        .cache-table th,
        .cache-table td {
          padding: 10px 8px;
          text-align: left;
          border-bottom: 1px solid var(--border);
          vertical-align: middle;
        }
        .cache-table th {
          background: #f8fafc;
          font-weight: 600;
          color: var(--muted);
          position: sticky;
          top: 0;
        }
        .cache-table tr:hover { background: #f8fafc; }
        .image-tag { font-weight: 600; color: var(--text); }
        .image-tag-wrap {
          overflow-wrap: anywhere;
          word-break: break-word;
          white-space: normal;
        }
        .uri-cell,
        .digest-cell {
          font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, monospace;
          font-size: 0.85em;
          overflow-wrap: anywhere;
          word-break: break-word;
          white-space: normal;
        }
        .actions-cell { white-space: nowrap; }
        .actions-cell .btn { padding: 6px 10px; font-size: 0.82em; }
        .actions-inline { display: inline-flex; gap: 6px; align-items: center; flex-wrap: nowrap; }
        .status-badge {
          padding: 4px 8px;
          border-radius: 0;
          font-size: 0.78em;
          font-weight: 700;
        }
        .status-200 { background: var(--green-weak); color: var(--green); }
        .status-307 { background: var(--blue-weak); color: var(--blue); }
        .status-other { background: var(--red-weak); color: var(--red); }
        .size-cell { font-weight: 600; color: #1d4ed8; }
        .time-cell { color: var(--muted); font-size: 0.85em; }
        .pagination-controls {
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          flex-wrap: wrap;
        }

        @media (max-width: 1200px) {
          .card { grid-column: span 6; }
        }
        @media (max-width: 900px) {
          .dashboard { grid-template-columns: repeat(6, 1fr); }
          .card { grid-column: span 6; }
          .cache-table-container { overflow-x: auto; }
          .cache-table { min-width: 980px; }
        }
        @media (max-width: 640px) {
          body { padding: 14px; }
          .header h1 { font-size: 1.4em; }
          .actions { flex-direction: column; align-items: stretch; }
          .btn { width: 100%; justify-content: center; }
        }

  body
    .container
      .header
        h1 Docker Registry Mirror Dashboard
        p Real-time monitoring and alerting for cache performance & redirect health

      .dashboard
        .card
          h2 Cache Metrics
          .metric
            span.metric-label Total Entries
            span.metric-value.status-info id="cache-entries" Loading...
          .metric
            span.metric-label Cache Size
            span.metric-value.status-info id="cache-size" Loading...
          .metric
            span.metric-label Expired Entries
            span.metric-value id="expired-entries" Loading...
          .metric
            span.metric-label TTL Settings
            span.metric-value.status-info id="cache-ttl" Loading...
          .metric
            span.metric-label Hit Rate
            span.metric-value id="hit-rate" Loading...
            .progress-bar
              .progress-fill id="hit-rate-bar"

        .card
          h2 Quick Actions
          .actions
            a.btn.btn-primary href="/cache/stats" target="_blank"
              | View Cache Stats
            button.btn.btn-secondary onclick="triggerCleanup()"
              | Manual Cleanup
            button.btn.btn-secondary onclick="triggerCleanupAll()"
              | Cleanup All
            button.btn.btn-secondary onclick="refreshDashboard()"
              | Refresh Data
            a.btn.btn-secondary href="/v2/" target="_blank"
              | Test Registry
          .actions
            input#quick-image-name placeholder="Image (e.g. dtorry/registry-mirror)" style="padding: 8px 10px; border: 1px solid var(--border); background: #fff; min-width: 260px;"
            input#quick-image-tag placeholder="Tag or digest (e.g. latest)" style="padding: 8px 10px; border: 1px solid var(--border); background: #fff; min-width: 180px;"
            button.btn.btn-primary onclick="requestCacheImage()"
              | Request & Cache

        .card style="grid-column: 1 / -1;"
          h2 Cached Images & Tags
          .actions
            input#cache-filter placeholder="Filter by image, tag, digest, or URI" style="padding: 8px 10px; border: 1px solid var(--border); background: #fff; min-width: 320px;"
            button.btn.btn-secondary onclick="clearCacheFilter()"
              | Clear
          .cache-table-container
            table.cache-table id="cache-entries-table"
              colgroup
                col style="width: 14%;"
                col style="width: 28%;"
                col style="width: 5%;"
                col style="width: 22%;"
                col style="width: 5%;"
                col style="width: 6%;"
                col style="width: 5%;"
                col style="width: 15%;"
              thead
                tr
                  th Image:Tag
                  th URI
                  th Status
                  th Digest
                  th Size
                  th Cached
                  th Fresh
                  th Actions
              tbody id="cache-entries-tbody"
                tr
                  td colspan="8" style="text-align: center; padding: 20px;" Loading entries...
          .logs id="status-panel" style="margin-top: 14px; background: #f8fafc; color: #1f2937; border: 1px solid var(--border);"
            .actions style="margin-bottom: 8px; justify-content: space-between; align-items: center;"
              strong Status Result
              button.btn.btn-secondary onclick="clearStatusResult()"
                | Close
            pre id="status-result" style="white-space: pre-wrap; word-break: break-word; font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, monospace; font-size: 12px; color: #111827;" No status checked yet.
          .pagination-controls id="pagination-controls" style="margin-top: 15px; text-align: center; display: none;"
            button.btn.btn-secondary onclick="loadCacheEntries(currentPage - 1)" id="prev-btn" disabled
              span ⬅️
              | Previous
            span.page-info id="page-info" style="margin: 0 15px; font-weight: bold;"
            button.btn.btn-secondary onclick="loadCacheEntries(currentPage + 1)" id="next-btn" disabled
              span ➡️
              | Next

      .logs
        h3 Recent Activity Logs
        div id="logs-container"
          .log-entry
            span.log-timestamp [Loading...]
            |  Initializing dashboard...

      .refresh-info
        p Dashboard auto-refreshes every 30 seconds
        p Last updated: 
          span id="last-updated" Loading...

    script
      |
        let currentPage = 1;
        let totalPages = 1;

        async function fetchCacheStats() {
          try {
            const response = await fetch('/cache/stats');
            if (response.ok) {
              const data = await response.json();
              updateCacheMetrics(data.cache);
            } else {
              console.error('Failed to fetch cache stats');
            }
          } catch (error) {
            console.error('Error fetching cache stats:', error);
          }
        }

        function updateCacheMetrics(cache) {
          document.getElementById('cache-entries').textContent = cache.total_entries;
          document.getElementById('cache-size').textContent = cache.total_size_mb + ' MB';
          document.getElementById('cache-ttl').textContent = Math.round(cache.ttl_seconds / 60) + ' min';
          
          const expiredEl = document.getElementById('expired-entries');
          expiredEl.textContent = cache.expired_entries;
          expiredEl.className = cache.expired_entries > 0 ? 'metric-value status-warning' : 'metric-value status-healthy';

          // Calculate hit rate (mock calculation)
          const hitRate = cache.total_entries > 0 ? Math.max(75, 100 - (cache.expired_entries / cache.total_entries * 100)) : 0;
          const hitRateEl = document.getElementById('hit-rate');
          hitRateEl.textContent = Math.round(hitRate) + '%';
          hitRateEl.className = hitRate > 80 ? 'metric-value status-healthy' : hitRate > 60 ? 'metric-value status-warning' : 'metric-value status-error';
          
          const hitRateBar = document.getElementById('hit-rate-bar');
          hitRateBar.style.width = hitRate + '%';
          hitRateBar.className = hitRate > 80 ? 'progress-fill progress-healthy' : hitRate > 60 ? 'progress-fill progress-warning' : 'progress-fill progress-error';

          addLogEntry('info', `Cache metrics updated: ${cache.total_entries} entries, ${cache.total_size_mb}MB`);
        }

        async function triggerCleanup() {
          try {
            const response = await fetch('/cache/cleanup', { method: 'POST' });
            if (response.ok) {
              const data = await response.json();
              addLogEntry('info', `Manual cleanup completed: ${data.cleanup.entries_removed} entries removed`);
              await fetchCacheStats();
            } else {
              addLogEntry('error', 'Manual cleanup failed');
            }
          } catch (error) {
            addLogEntry('error', `Cleanup error: ${error.message}`);
          }
        }

        async function triggerCleanupAll() {
          try {
            const response = await fetch('/cache/cleanup_all', { method: 'POST' });
            if (response.ok) {
              const data = await response.json();
              addLogEntry('warn', `Cleanup all completed: ${data.cleanup.entries_removed} entries removed`);
              await fetchCacheStats();
              await loadCacheEntries(1);
            } else {
              addLogEntry('error', 'Cleanup all failed');
            }
          } catch (error) {
            addLogEntry('error', `Cleanup all error: ${error.message}`);
          }
        }

        function addLogEntry(level, message) {
          const timestamp = new Date().toLocaleTimeString();
          const logContainer = document.getElementById('logs-container');
          const logEntry = document.createElement('div');
          logEntry.className = 'log-entry';
          logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> <span class="log-level-${level}">[${level.toUpperCase()}]</span> ${message}`;
          logContainer.insertBefore(logEntry, logContainer.firstChild);
          
          // Keep only last 50 entries
          if (logContainer.children.length > 50) {
            logContainer.removeChild(logContainer.lastChild);
          }
        }

        async function refreshDashboard() {
          addLogEntry('info', 'Refreshing dashboard data...');
          await fetchCacheStats();
          document.getElementById('last-updated').textContent = new Date().toLocaleString();
          addLogEntry('info', 'Dashboard refresh completed');
        }

        async function loadCacheEntries(page = 1) {
          if (page < 1 || page > totalPages) return;
          
          currentPage = page;
          
          try {
            const filterValue = (document.getElementById('cache-filter').value || '').trim();
            const filterParam = filterValue ? `&q=${encodeURIComponent(filterValue)}` : '';
            const response = await fetch(`/cache/entries?page=${page}&per_page=10${filterParam}`);
            if (response.ok) {
              const data = await response.json();
              updateCacheEntriesTable(data.entries);
              updatePaginationControls(data.pagination);
              addLogEntry('info', `Loaded cache entries page ${page}`);
            } else {
              addLogEntry('error', 'Failed to load cache entries');
            }
          } catch (error) {
            addLogEntry('error', `Error loading cache entries: ${error.message}`);
          }
        }

        function updateCacheEntriesTable(entries) {
          const tbody = document.getElementById('cache-entries-tbody');
          
          if (entries.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #718096;">No cache entries found</td></tr>';
            return;
          }
          
          tbody.innerHTML = entries.map(entry => {
            const imageTag = entry.image_name !== 'N/A' && entry.tag !== 'N/A' 
              ? `${entry.image_name}:${entry.tag}` 
              : 'System/API';
              
            const statusClass = entry.status === 200 ? 'status-200' : 
                               entry.status === 307 ? 'status-307' : 'status-other';
            const freshText = entry.expired ? 'Expired' : 'Fresh';
            const freshClass = entry.expired ? 'status-badge status-other' : 'status-badge status-200';
            const canAct = entry.image_name !== 'N/A' && entry.tag !== 'N/A';
            const safeImage = encodeURIComponent(entry.image_name || '');
            const safeTag = encodeURIComponent(entry.tag || '');
            const actionButtons = canAct ? `
              <span class="actions-inline">
                <button class="btn btn-secondary" onclick="forceRefreshEntry('${safeImage}','${safeTag}')">Force Update</button>
                <button class="btn btn-secondary" onclick="checkStatusEntry('${safeImage}','${safeTag}')">Check Status</button>
                <button class="btn btn-secondary" onclick="removeEntry('${safeImage}','${safeTag}')">Remove</button>
              </span>
            ` : '<span style="color: #718096;">N/A</span>';
            
            return `
              <tr>
                <td class="image-tag image-tag-wrap">${imageTag}</td>
                <td class="uri-cell" title="${entry.uri}">${entry.uri}</td>
                <td><span class="status-badge ${statusClass}">${entry.status}</span></td>
                <td class="digest-cell">${entry.digest || 'N/A'}</td>
                <td class="size-cell">${entry.size_formatted}</td>
                <td class="time-cell">${entry.cached_ago}</td>
                <td><span class="${freshClass}">${freshText}</span></td>
                <td class="actions-cell">${actionButtons}</td>
              </tr>
            `;
          }).join('');
        }

        async function forceRefreshEntry(image, tag) {
          try {
            const response = await fetch(`/cache/refresh?image=${image}&tag=${tag}`, { method: 'POST' });
            const data = await response.json();
            if (response.ok) {
              addLogEntry('info', `Force update: ${decodeURIComponent(image)}:${decodeURIComponent(tag)} status ${data.refresh.status}`);
              await loadCacheEntries(currentPage);
              await fetchCacheStats();
            } else {
              addLogEntry('error', data.error || 'Force update failed');
            }
          } catch (error) {
            addLogEntry('error', `Force update error: ${error.message}`);
          }
        }

        async function requestCacheImage() {
          const image = document.getElementById('quick-image-name').value.trim();
          const tag = document.getElementById('quick-image-tag').value.trim();

          if (!image || !tag) {
            addLogEntry('error', 'Image and tag are required to request cache');
            return;
          }

          try {
            const response = await fetch(`/cache/refresh?image=${encodeURIComponent(image)}&tag=${encodeURIComponent(tag)}`, { method: 'POST' });
            const data = await response.json();
            if (response.ok) {
              addLogEntry('info', `Requested cache: ${image}:${tag} status ${data.refresh.status}`);
              await loadCacheEntries(currentPage);
              await fetchCacheStats();
            } else {
              addLogEntry('error', data.error || 'Request cache failed');
            }
          } catch (error) {
            addLogEntry('error', `Request cache error: ${error.message}`);
          }
        }

        async function checkStatusEntry(image, tag) {
          try {
            const response = await fetch(`/cache/image_status?image=${image}&tag=${tag}`);
            const data = await response.json();
            if (response.ok) {
              const digestNote = data.comparison && data.comparison.digest_matches === true ? 'digest matches upstream' :
                data.comparison && data.comparison.digest_matches === false ? 'digest differs from upstream' :
                'digest unknown';
              addLogEntry('info', `Status: ${decodeURIComponent(image)}:${decodeURIComponent(tag)} upstream ${data.upstream.status}, ${digestNote}`);
              const statusResult = document.getElementById('status-result');
              if (statusResult) {
                statusResult.textContent = JSON.stringify(data, null, 2);
              }
              const statusPanel = document.getElementById('status-panel');
              if (statusPanel) {
                statusPanel.style.display = '';
              }
            } else {
              addLogEntry('error', data.error || 'Status check failed');
              const statusResult = document.getElementById('status-result');
              if (statusResult) {
                statusResult.textContent = JSON.stringify(data, null, 2);
              }
              const statusPanel = document.getElementById('status-panel');
              if (statusPanel) {
                statusPanel.style.display = '';
              }
            }
          } catch (error) {
            addLogEntry('error', `Status check error: ${error.message}`);
            const statusResult = document.getElementById('status-result');
            if (statusResult) {
              statusResult.textContent = error.message;
            }
            const statusPanel = document.getElementById('status-panel');
            if (statusPanel) {
              statusPanel.style.display = '';
            }
          }
        }

        function clearStatusResult() {
          const statusPanel = document.getElementById('status-panel');
          const statusResult = document.getElementById('status-result');
          if (statusResult) {
            statusResult.textContent = 'No status checked yet.';
          }
          if (statusPanel) {
            statusPanel.style.display = 'none';
          }
        }

        let filterDebounce;
        function applyCacheFilter() {
          clearTimeout(filterDebounce);
          filterDebounce = setTimeout(() => {
            loadCacheEntries(1);
          }, 200);
        }

        function clearCacheFilter() {
          const input = document.getElementById('cache-filter');
          input.value = '';
          loadCacheEntries(1);
        }

        async function removeEntry(image, tag) {
          try {
            const response = await fetch(`/cache/remove?image=${image}&tag=${tag}`, { method: 'POST' });
            const data = await response.json();
            if (response.ok) {
              addLogEntry('warn', `Removed cache: ${decodeURIComponent(image)}:${decodeURIComponent(tag)} (${data.remove.entries_removed} entries)`);
              await loadCacheEntries(currentPage);
              await fetchCacheStats();
            } else {
              addLogEntry('error', data.error || 'Remove failed');
            }
          } catch (error) {
            addLogEntry('error', `Remove error: ${error.message}`);
          }
        }

        function updatePaginationControls(pagination) {
          totalPages = pagination.total_pages;
          currentPage = pagination.page;
          
          const controls = document.getElementById('pagination-controls');
          const prevBtn = document.getElementById('prev-btn');
          const nextBtn = document.getElementById('next-btn');
          const pageInfo = document.getElementById('page-info');
          
          // Show/hide controls
          controls.style.display = totalPages > 1 ? 'flex' : 'none';
          
          // Update buttons
          prevBtn.disabled = !pagination.has_prev;
          nextBtn.disabled = !pagination.has_next;
          
          // Update page info
          pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${pagination.total_count} total entries)`;
        }

        // Auto-refresh every 30 seconds
        setInterval(() => {
          refreshDashboard();
          loadCacheEntries(currentPage); // Refresh current page
        }, 30000);

        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
          addLogEntry('info', 'Dashboard initialized');
          refreshDashboard();
          loadCacheEntries(1);
          const filterInput = document.getElementById('cache-filter');
          if (filterInput) {
            filterInput.addEventListener('input', applyCacheFilter);
          }
          clearStatusResult();
        });
